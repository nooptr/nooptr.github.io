<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Tech Blog</title>
		<description>Stylish Jekyll Theme</description>
		<link>/</link>
		<atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Hiệu quả của exponential backoff trong xử lí error retries</title>
				<description>&lt;h2 id=&quot;li-m-u&quot;&gt;Lời mở đầu&lt;/h2&gt;
&lt;p&gt;Khi làm việc với API chắc hẳn ai cũng không lạ lẫm gì với các vấn đề liên quan đến gửi nhận dữ liệu như: đang gửi thì server bị lỗi đến đến gửi thất bại, rồi thì rõ ràng khi thất bại mình đã retries lại mấy lần rồi mà sao vẫn bị lỗi …. vân vân và vân vân …&lt;/p&gt;

&lt;p&gt;Một trong những kĩ thuật khá đơn giản để giải quyết vấn đề này là thực hiện 1 logic retries request đó.
Logic retries mà đa số chúng ta viết thì đều như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;retries = 0

DO
    wait 1 second

    status = Get the result of response

    IF status = SUCCESS
        retry = false
    ELSE
        retry = true
    END IF

    retries = retries + 1

WHILE (retry AND (retries &amp;lt; MAX_RETRIES))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nhìn thuật toán bên trên dường như &lt;code&gt;quá perfect???&lt;/code&gt; nhưng mà khi suy nghĩ kĩ hơn thì nó thật sự không hiểu quả trong 1 số trường hợp.
Vậy chúng ta hãy cùng đi xem nó là gì nhé.&lt;/p&gt;

&lt;p&gt;OK. Let’s Go.&lt;/p&gt;

&lt;h2 id=&quot;exponential-backoff-l-g&quot;&gt;Exponential Backoff là gì?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Exponential Backoff&lt;/code&gt; là 1 thuật toán tính toán thời gian đợi giữa mỗi lần retries theo hàm luỹ kế để việc thực hiện gửi lại request được hiệu quả nhất.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ví dụ như lần retries thứ 1 sẽ đợi 1s, lần retries thứ 2 sẽ đợi 2s, lần thứ 3 sẽ đợi 4s …. Tức là chúng ta sẽ làm thời gian đợi sau mỗi lần retries kéo dài ra mà không fix cứng thời gian wait như trước nữa và theo thống kê thì làm như này sẽ rất hiệu quả.&lt;/p&gt;

&lt;h2 id=&quot;vn--g-nu-khng-dng-exponential-backoff&quot;&gt;Vấn đề gì nếu không dùng Exponential Backoff?&lt;/h2&gt;

&lt;p&gt;Vậy với thuật toán ở bên trên chúng ta thấy nó đang gặp vấn đề gì?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Giả sử như lần đầu tiên chúng ta có N client đồng thời gửi request. Cả N request này đều gửi thất bại và yêu cầu retries lại. 
Như chúng ta thấy bên trên thì sau 1s cả N client này đều gửi lại request đó. Hãy tưởng tượng server lúc đó đang trong trạng thái quá tải. 
Nếu N client lại gửi request đồng thời sau 1s thì chẳng phải điều này là rất tệ đúng không ak? Server không thể nào handle được tất cả các request đó được.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nếu thời gian gửi lại của các client này mà khác nhau đi thì có lẽ hiệu quả sẽ cao hơn. 
Chính vì lí do này mà &lt;code&gt;Exponential Backoff&lt;/code&gt; đã ra đời.&lt;/p&gt;

&lt;h2 id=&quot;ci-t-thut-ton-exponential-backoff&quot;&gt;Cài đặt thuật toán Exponential Backoff&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;retries = 0

DO
    wait for random from 0 to (2^retries * 100) milliseconds

    status = Get the result of response

    IF status = SUCCESS
        retry = false
    ELSE
        retry = true
    END IF

    retries = retries + 1

WHILE (retry AND (retries &amp;lt; MAX_RETRIES))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Với cài đặt trên thì chúng ta có thể thấy. Nếu request của N client đều thất bại và yêu cầu retries thì lúc này sẽ retries như sau.
Client 1 sẽ đợi 1 khoảng thời gian là 1 số random từ 0 ~ (2^retries * 100) ms
Client 2 sẽ đợi 1 khoảng thời gian là 1 số random từ 0 ~ (2^retries * 100) ms
…&lt;/p&gt;

&lt;p&gt;Cứ như thế thì khoảng thời gian mà mỗi client này gửi request lại phía server sẽ khác nhau đi. Nhờ việc tránh gửi đồng thời này dẫn đến hiệu quả cao hơn.&lt;/p&gt;

&lt;h2 id=&quot;v-d-thc-t&quot;&gt;Ví dụ thực tế&lt;/h2&gt;

&lt;p&gt;Bây giờ hãy thử xem các ông trùm lớn như Google, Amazon … đã thực thi nó như thế nào nhé.&lt;/p&gt;

&lt;h4 id=&quot;google-http-client&quot;&gt;1. Google HTTP client&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;retry_interval = retry_interval * multiplier ^ (N - 1)
randomized_interval := retry_interval * (random value in range [1 - randomization_factor, 1 + randomization_factor])
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Nếu status code của response là 500 hoặc 503 thì sẽ tiến hành retries.&lt;/li&gt;
  &lt;li&gt;Giá trị default của &lt;code&gt;retry_interval = 0.5s&lt;/code&gt;, &lt;code&gt;randomization_factor = 0.5&lt;/code&gt;, &lt;code&gt;multiplier = 1.5&lt;/code&gt;, &lt;code&gt;max_interval = 1 minute&lt;/code&gt;, &lt;code&gt;max_elapsed_time = 15s&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Nếu &lt;code&gt;retry_interval &amp;gt; max_elapsed_time (15s)&lt;/code&gt; thì stop retries (mặc định là 10 lần)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;request retry_interval randomized_interval
01      00.50          [0.25, 0.75]
02      00.75          [0.38, 1.12]
03      01.12          [0.56, 1.69]
04      01.69          [0.84, 2.53]
05      02.53          [1.27, 3.80]
06      03.80          [1.90, 5.70]
07      05.70          [2.85, 8.54]
08      08.54          [4.27, 12.81]
09      12.81          [6.41, 19.22]
10      19.22          STOP
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;aws-simpledb&quot;&gt;2. AWS SimpleDB&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;currentRetry = 0
 DO
   status = execute Amazon SimpleDB request
   IF status = success OR status = client error (4xx)
     set retry to false
     process the response or client error as appropriate
   ELSE
     set retry to true
     currentRetry = currentRetry + 1
     wait for a random delay between 0 and (4^currentRetry * 100) milliseconds
   END-IF
 WHILE (retry = true AND currentRetry &amp;lt; MaxNumberOfRetries) 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Kết quả:

request randomized_interval
1       [0, 400)
2       [0, 1600)
3       [0, 6400)
4       [0, 25600)
5       [0, 102400)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;kt-lun&quot;&gt;Kết luận&lt;/h2&gt;

&lt;p&gt;Qua bài giới thiệu của mình hẳn các bạn cũng có cái nhìn khác về thuật toán retries rồi đúng không ak?
Vậy còn chần chừ gì nữa, hãy sửa lại thuật toán để trở thành những pro nào.&lt;/p&gt;

&lt;h3 id=&quot;ngun-tham-kho&quot;&gt;Nguồn tham khảo&lt;/h3&gt;

&lt;p&gt;Error Retries and Exponential Backoff in AWS:&lt;/p&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://docs.aws.amazon.com/general/latest/gr/api-retries.html&quot;&gt;https://docs.aws.amazon.com/general/latest/gr/api-retries.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Exponential Backoff And Jitter:&lt;/p&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.awsarchitectureblog.com/2015/03/backoff.html&quot;&gt;https://www.awsarchitectureblog.com/2015/03/backoff.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Building for Performance and Reliability with Amazon SimpleDB:&lt;/p&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://aws.amazon.com/articles/Amazon-SimpleDB/1394&quot;&gt;https://aws.amazon.com/articles/Amazon-SimpleDB/1394&lt;/a&gt;&lt;/p&gt;

</description>
				<pubDate>Mon, 17 Apr 2017 21:30:00 +0900</pubDate>
				<link>/pattern/2017/04/17/hieu-qua-cua-exponential-backoff-trong-xu-li-error-retries.html</link>
				<guid isPermaLink="true">/pattern/2017/04/17/hieu-qua-cua-exponential-backoff-trong-xu-li-error-retries.html</guid>
			</item>
		
			<item>
				<title>Amazon SQS là gì</title>
				<description>&lt;p&gt;Mình cũng đã nghe qua khá nhiều về cái tên SQS (Simple Queue Service) nhưng mà chưa từng lần nào tìm hiểu hẳn hoi tử tế. Hôm nay quyét tâm dành thời gian ra tìm hiểu nó.
Thực ra mình đang định thi chứng chỉ Amazon Web Service mà trong đó thấy nó nói nhiều về SQS quá nên không tìm hiểu sâu không được.
Thôi không nói lan man nữa. Vào vấn đề chính thôi.&lt;/p&gt;

&lt;h3 id=&quot;sqs-l-g&quot;&gt;1. SQS là gì?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Amazon Simple Queue Service&lt;/code&gt; là 1 dịch vụ về hàng đợi lưu trữ thông điệp (message) 1 cách nhanh chóng, đáng tin cậy và có khả năng mở rộng cao.&lt;/li&gt;
  &lt;li&gt;Và đặc biệt là nó khá rẻ ($0.4 với 1 triệu requests)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sqs-lm-c-g&quot;&gt;2. SQS làm được gì?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Với 1 queue, nó có thể gửi, nhận, xoá message.&lt;/li&gt;
  &lt;li&gt;Với 1 số tính năng mà không yêu cầu tính realtime thì ta có thể gửi message đến queue và xử lí sau đó thông qua batch.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;c-th-sqs-c-s-dng-nh-th-no&quot;&gt;3. Cụ thể SQS được sử dụng như thế nào?&lt;/h3&gt;

&lt;p&gt;Để dễ hiểu bây giờ mình sẽ lấy 1 ví dụ về logic nạp tiền trong game.  Khi đó với trường hợp không sử dụng SQS với trường hợp sử dụng SQS nó khác nhau thế nào?&lt;/p&gt;

&lt;h4 id=&quot;a-khng-s-dng-sqs&quot;&gt;a. Không sử dụng SQS&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Khi người dùng nạp tiền trong game, đa số chúng ta đều viết logic xử lí payment đồng thời với việc ghi log vào trong DB.&lt;/li&gt;
  &lt;li&gt;Giả sử như việc ghi log vào DB là 1 việc cần thiết. Vì 1 lí do nào đó mà logic nào đó mà việc ghi log vào trong DB bị lỗi dẫn đến toàn bộ xử lí bị stop lại và đồng thời thông báo tin nhắn ERROR đến người dùng.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;b-s-dng-sqs&quot;&gt;b. Sử dụng SQS&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Khi người dùng tiến hành nạp tiền thì sẽ gửi 1 message ghi log đến SQS và sẽ thực hiện việc xử lí ghi log này về sau thông qua batch.&lt;/li&gt;
  &lt;li&gt;Nhờ vào việc xử lí này mà thời gian xử lí toàn bộ logic của hệ thống cũng giảm xuống và nó cũng không gây ảnh hưởng gì đến logic xử lí payment coin.&lt;/li&gt;
  &lt;li&gt;Đối với message đang được lưu trên SQS thì sẽ được xử lí thông qua batch từ 1 server khác được chạy định kì.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-dng-thc-t&quot;&gt;4. Áp dụng thực tế&lt;/h3&gt;

&lt;p&gt;Sau đây mình xin viết 1 đoạn code demo về việc tương tác với SQS như sau:&lt;/p&gt;

&lt;p&gt;※ Mình sẽ không hướng dẫn các bạn cài đặt SQS trên AWS nhé. Các bạn có thể tham khảo về việc cài đặt ở link cuối bài.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Make a SQS instance&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function static get_sqs_client()
{
    $client = new SqsClient([
      'version' =&amp;gt; 'latest',
      'region' =&amp;gt; Region::TOKYO
    ]);

    return $client;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Send message to SQS&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static function send_sqs_message($sqs_name, $data) {
  // Get SQS instance
  $client = self::get_sqs_client();

  // Send message to SQS
  $client-&amp;gt;sendMessage(array(
    'QueueUrl'    =&amp;gt; &quot;https://sqs.ap-northeast-1.amazonaws.com/[QUEUE_ID]/{$sqs_name}&quot;,
    'MessageBody' =&amp;gt; json_encode($data),
  ));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Receive message from SQS&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static function receive_sqs_message() {
  // Get SQS instance
  $client = self::get_sqs_client();

  // Get Queue URL
  $listqueues = $client-&amp;gt;listQueues();
  $queueUrls  = $listqueues['QueueUrls'];

  // Get message from Queue
  foreach ($queueUrls as $queueUrl) {
    $result = $client-&amp;gt;receiveMessage(array(
      'QueueUrl' =&amp;gt; $queueUrl,
      'MaxNumberOfMessages' =&amp;gt; 10,
      'WaitTimeSeconds' =&amp;gt; 20
    ));

    foreach ($result-&amp;gt;getPath('Messages') as $messageBody) {
      $data = json_decode($messageBody);

      // array('user_id' =&amp;gt; '1', 'purchase_date' =&amp;gt; '20140501', 'price' =&amp;gt; '9800');
      $values = $data['values'];

      // TODO Process log to DB
      $target_table = $data['target_table'];
      Model_Logs::insert_log($target_table, $values);

      // Delete message from SQS
      $ReceiptHandle = $messageBody['ReceiptHandle'];
      $client-&amp;gt;deleteMessage([
        'QueueUrl' =&amp;gt; $queueUrl,
        'ReceiptHandle' =&amp;gt; $ReceiptHandle
      ]);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hi vọng bài viết của mình sẽ giúp ích cho các bạn khi tìm hiểu về SQS.&lt;/p&gt;

&lt;h3 id=&quot;ngun-tham-kho&quot;&gt;Nguồn tham khảo&lt;/h3&gt;

&lt;p&gt;AWS SDK for PHP:&lt;/p&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://docs.aws.amazon.com/aws-sdk-php/v3/guide/getting-started/installation.html&quot;&gt;http://docs.aws.amazon.com/aws-sdk-php/v3/guide/getting-started/installation.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Guide SQS for AWS SDK PHP:&lt;/p&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://docs.aws.amazon.com/aws-sdk-php/v2/guide/service-sqs.html&quot;&gt;http://docs.aws.amazon.com/aws-sdk-php/v2/guide/service-sqs.html&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Wed, 01 Mar 2017 21:40:00 +0900</pubDate>
				<link>/aws/2017/03/01/amazon-sqs-la-gi.html</link>
				<guid isPermaLink="true">/aws/2017/03/01/amazon-sqs-la-gi.html</guid>
			</item>
		
			<item>
				<title>Xu hướng thiết kế web 2017</title>
				<description>&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23362744/96c70c20-fd3a-11e6-97f9-12f4eb6224fc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Là 1 kĩ sư lập trình suốt ngày chỉ ngồi code code mà không để ý đến gái gú, đến khi 30 tuổi vẫn FA thì lại trách đời như sh..t.  Thôi  không nói linh tinh nữa, quay về vấn đề chính thôi.&lt;/p&gt;

&lt;p&gt;Lập trình web hay lập trình di động cũng vậy. Design là 1 trong những yếu tố khá quan trọng để làm nổi bật trong mắt người dùng.&lt;/p&gt;

&lt;p&gt;Không biết người khác thế nào, chứ mình mà thấy trang web hay app nào mà giao diện trông như shit thì cho dù chức năng có ngon đến đâu mình cũng không dùng. Gặp gái ngoài đường cũng thế, em nào nhìn xinh tươi chỉ muốn vào bắt chuyện, xin zalo …. =))&lt;/p&gt;

&lt;p&gt;Hôm nay mình giới thiệu cho các bạn 1 số xu thế thiết kế web năm 2017.&lt;/p&gt;

&lt;h2 id=&quot;flat&quot;&gt;01. Flat&lt;/h2&gt;
&lt;p&gt;Trong những năm gần đây thì thiết kế kiểu Flat cũng đang rất thịnh hành.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363440/fdc624da-fd3d-11e6-903d-41528f498129.jpg&quot; alt=&quot;1-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363442/ffa4c2ca-fd3d-11e6-9781-4ef7d7080d4e.jpg&quot; alt=&quot;1-2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cinemagraphs&quot;&gt;02. Cinemagraphs&lt;/h2&gt;

&lt;p&gt;Là dạng ảnh động được lưu dưới dạng file .gif. Giống như hầu hết ảnh động GIF thông thường, Cinemagraph chứa hình ảnh có các yếu tố di chuyển.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363552/8551ced6-fd3e-11e6-8661-e8b2cf99d412.gif&quot; alt=&quot;2-1&quot; /&gt;
&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363554/866ec292-fd3e-11e6-8034-92510dfee48f.gif&quot; alt=&quot;2-2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;d&quot;&gt;03. 3D&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363591/c739b25a-fd3e-11e6-879c-82205d0fbfa5.jpg&quot; alt=&quot;3-1&quot; /&gt;
&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363593/c743c8c6-fd3e-11e6-94d5-fedd33932786.jpg&quot; alt=&quot;3-2&quot; /&gt;
&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363592/c742c3ae-fd3e-11e6-9f1d-628b1c14e6cf.jpg&quot; alt=&quot;3-4&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;animation&quot;&gt;04. Animation&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363628/f620b848-fd3e-11e6-8c6c-5040cb459335.gif&quot; alt=&quot;4-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363629/f6229834-fd3e-11e6-9a26-ac8bc0c71feb.gif&quot; alt=&quot;4-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363630/f62891da-fd3e-11e6-856e-00759607fa0d.gif&quot; alt=&quot;4-3&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;line&quot;&gt;05. Line&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363717/5ecb66b8-fd3f-11e6-9cea-91b931415172.jpg&quot; alt=&quot;5-2&quot; /&gt;
&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363721/609b7af0-fd3f-11e6-8caa-8cb813df1930.jpg&quot; alt=&quot;5-3&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;color-schema&quot;&gt;06. Color Schema&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363756/8e69f434-fd3f-11e6-83e6-e86db03480cd.jpg&quot; alt=&quot;7-3&quot; /&gt;
&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363757/8e7b625a-fd3f-11e6-9768-957fa60ef2ec.jpg&quot; alt=&quot;7-4&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;scroll-vs-parallax&quot;&gt;07. Scroll vs Parallax&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363799/c3d1c6c4-fd3f-11e6-8344-2ae2564604d6.gif&quot; alt=&quot;giphy6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363801/c4171210-fd3f-11e6-9701-ff0557083d3c.gif&quot; alt=&quot;giphy7&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;gradient-color&quot;&gt;08. Gradient color&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363846/f77e7dd2-fd3f-11e6-85c3-5daa32f6ae7f.jpg&quot; alt=&quot;9-1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;lazy-loading&quot;&gt;09. Lazy Loading&lt;/h2&gt;

&lt;p&gt;Lazy Loading là kĩ thuật làm delay thời gian đọc file ảnh trong trang web có nhiều nội dung. Khi chúng ta scroll thì ảnh mới được load về.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363929/5a009abc-fd40-11e6-9362-1963118986b8.jpg&quot; alt=&quot;14-1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;full-screen-form&quot;&gt;10. Full Screen Form&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363960/7d176e86-fd40-11e6-81a7-14d2c73e5b6f.jpg&quot; alt=&quot;16-1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;video&quot;&gt;11. Video&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23363990/952f0c86-fd40-11e6-8511-21a176529473.gif&quot; alt=&quot;giphy8&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;logo&quot;&gt;12. Logo&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23364081/fcfc38e8-fd40-11e6-96b6-25ae48676f66.jpg&quot; alt=&quot;21-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23364082/fcff3098-fd40-11e6-97ca-f8e35838093e.jpg&quot; alt=&quot;21-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23364083/fd02a192-fd40-11e6-917f-66cffd1931e4.jpg&quot; alt=&quot;21-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23364084/fd06ac10-fd40-11e6-8c68-0ddcd2e5bdf3.jpg&quot; alt=&quot;21-4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23364085/fd097aee-fd40-11e6-96f6-9aa90ce7718c.jpg&quot; alt=&quot;21-5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23364086/fd0cfa3e-fd40-11e6-99c4-57822ae3b76c.jpg&quot; alt=&quot;21-6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23364088/fd2babe6-fd40-11e6-8267-99203c9b19ed.jpg&quot; alt=&quot;21-7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23364087/fd2b4552-fd40-11e6-8daf-02e2768cc084.jpg&quot; alt=&quot;21-11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23364089/fd2ff11a-fd40-11e6-99de-b6222cf00f14.jpg&quot; alt=&quot;21-13&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23364107/0487728a-fd41-11e6-8a05-b6a5ea12b52f.gif&quot; alt=&quot;giphy9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5398914/23364108/04b34928-fd41-11e6-8ff4-3bc02d567164.gif&quot; alt=&quot;giphy10&quot; /&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 27 Feb 2017 23:00:00 +0900</pubDate>
				<link>/web/2017/02/27/xu-huong-thiet-ke-web-2017.html</link>
				<guid isPermaLink="true">/web/2017/02/27/xu-huong-thiet-ke-web-2017.html</guid>
			</item>
		
			<item>
				<title>Inbound/Outbound data transfer</title>
				<description>&lt;p&gt;Mặc dù mình đã từng làm việc với AWS cũng được 1 thời gian nhưng mà còn lơ mơ về vấn đề &lt;code&gt;Inbound&lt;/code&gt; vs &lt;code&gt;Outbound&lt;/code&gt;. Không biết &lt;code&gt;Inbound&lt;/code&gt; là vào hay là ra AWS nữa?? Hoang mang vãi.
Hôm nay quyết định tìm hiểu kĩ càng xem nó là cái gì.&lt;/p&gt;

&lt;p&gt;Sau 1 hồi tìm hiểu các kiểu con đà điểu cuối cùng cũng đã hiểu nó là cái gì.&lt;/p&gt;

&lt;p&gt;Inbound thì sẽ là cái hướng về phía AWS. còn Outbound sẽ là từ phía AWS hướng ra phía ngoài.
Cụ thể như sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Inbound&lt;/code&gt;: khi upload đến server hoặc là khi client gửi request lên server.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Outbound&lt;/code&gt;: Khi download 1 file từ server hoặc khi nhận response từ phía server trả về phía client.&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Mon, 20 Feb 2017 23:10:00 +0900</pubDate>
				<link>/aws/2017/02/20/inbound-and-outbound-data-transfer.html</link>
				<guid isPermaLink="true">/aws/2017/02/20/inbound-and-outbound-data-transfer.html</guid>
			</item>
		
			<item>
				<title>NoSQL vs SQL</title>
				<description>&lt;h2 id=&quot;nosql-vs-sql&quot;&gt;NoSQL vs SQL&lt;/h2&gt;

&lt;p&gt;Hầu hết tất cả chúng ta cũng đã từng nghe qua về RDBMS - Relational Database Management System (Hệ thống quản lý cơ sở dữ liệu quan hệ).
Tuy nhiên, với sự tăng trưởng nhanh chóng về dữ liệu thì việc xử lí tốc độ nhanh là điều cực kì quan trọng.
RDBMS mặc dù được nhiều developer ưa chuộng thế nhưng với 1 số bài toán khác có thể hiệu năng của nó không cao và nhiều khi còn khá là chậm, vì chúng ta sẽ phải join nhiều bảng hơn mới có thể lấy được dữ liệu mong muốn.
Để giải quyết 1 số vấn đề đó thì NoSQL đã ra đời.&lt;/p&gt;

&lt;p&gt;NoSQL được sử dụng vì múc đích đưa ra hướng quản lí dữ liệu “Not only SQL”, hoặc là hệ thống quản lí dữ liệu tương ứng với “Not SQL”.
Có rất nhiều kĩ thuật trong NoSQL như Document database, key-value … và những cái này thường hay được dùng trong ứng dụng game app, social app, IoT app.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/ja-jp/azure/documentdb/media/documentdb-nosql-vs-sql/nosql-vs-sql-overview.png&quot; alt=&quot;80x50&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;trng-hp-s-dng-nosql&quot;&gt;Trường hợp sử dụng NoSQL&lt;/h2&gt;

&lt;p&gt;Bây giờ mình sẽ lấy 1 ví dụ về chức năng comment và post bài trong trang blog để mọi người dễ hiểu nhé. Cụ thể như sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Người dùng có thể tạo bài viết. Hơn nữa có thể thêm ảnh, thêm video.&lt;/li&gt;
  &lt;li&gt;Người dùng khác có thể comment bài viết, cho điểm đánh giá bài viết.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vậy dữ liệu của chúng ta sẽ được lưu như thế nào? Với những thanh niên nào đã ưa chuộng MySQL chắc hẳn sẽ đưa ra 1 cấu trúc schema như ở bên dưới.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/ja-jp/azure/documentdb/media/documentdb-nosql-vs-sql/nosql-vs-sql-social.png&quot; alt=&quot;80x50&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OK, bây giờ đã có database rồi. Nhìn có vẻ ngon =)) Bây giờ hãy thử suy nghĩ khi hiển thị dữ liệu về bài viết, cả comment, video, ảnh trên web sẽ như thế nào nhé.
Để lấy được hết dữ liệu cần thiết chúng ta phải join đến 8 bảng. ôi fukkk :’(
Với dữ liệu lớn có khi sẽ mất đến mấy chục đến hàng trăm câu query cũng nên.&lt;/p&gt;

&lt;p&gt;Với vấn đề này thì có lẽ NoSQL là 1 giải pháp tốt hơn. Với NoSQL chúng ta có thể lưu toàn bộ thông tin vào trong 1 đối tượng được gọi là DocumentDB, do đó mà có thể cải thiện được hiệu năng, 
chỉ cần 1 câu query không cần join có thể lấy được dữ liệu mong muốn.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;id&quot;:&quot;ew12-res2-234e-544f&quot;,
    &quot;title&quot;:&quot;post title&quot;,
    &quot;date&quot;:&quot;2016-01-01&quot;,
    &quot;body&quot;:&quot;this is an awesome post stored on NoSQL&quot;,
    &quot;createdBy&quot;:User,
    &quot;images&quot;:[&quot;http://myfirstimage.png&quot;,&quot;http://mysecondimage.png&quot;],
    &quot;videos&quot;:[
        {&quot;url&quot;:&quot;http://myfirstvideo.mp4&quot;, &quot;title&quot;:&quot;The first video&quot;},
        {&quot;url&quot;:&quot;http://mysecondvideo.mp4&quot;, &quot;title&quot;:&quot;The second video&quot;}
    ],
    &quot;audios&quot;:[
        {&quot;url&quot;:&quot;http://myfirstaudio.mp3&quot;, &quot;title&quot;:&quot;The first audio&quot;},
        {&quot;url&quot;:&quot;http://mysecondaudio.mp3&quot;, &quot;title&quot;:&quot;The second audio&quot;}
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;s-khc-nhau-gia-nosql-vs-sql&quot;&gt;Sự khác nhau giữa NoSQL vs SQL&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/ja-jp/azure/documentdb/media/documentdb-nosql-vs-sql/nosql-vs-sql-comparison.png&quot; alt=&quot;80x50&quot; /&gt;&lt;/p&gt;

</description>
				<pubDate>Sun, 19 Feb 2017 20:10:00 +0900</pubDate>
				<link>/database/2017/02/19/nosql-vs-sql.html</link>
				<guid isPermaLink="true">/database/2017/02/19/nosql-vs-sql.html</guid>
			</item>
		
			<item>
				<title>Garbage Collector trong Ruby</title>
				<description>&lt;p&gt;Đến 1 ngày đẹp trời nào đó, trang web mà mình đang vận hành tự nhiên chạy chậm lại. Đa số đều nghĩ ngay đến việc khởi động lại server web xem thế nào.
Và kết quả tốc độ trang web lại nhanh hơn. Wtf???&lt;/p&gt;

&lt;p&gt;Đến ngay cả con router của mình cũng thế, cứ khi nào mạng chậm lại chạy đi khởi động lại con router và kết quả là tốc độ mạng cũng nhanh hơn =))&lt;/p&gt;

&lt;p&gt;Có 1 số nguyên nhân có thể xảy ra như thiếu memory, mạng chậm … Có 1 nguyên nhân có thể gây ảnh hưởng đến ứng dụng mà ít ai để ý đó là Garbage Collector (Bộ thu gom rác)&lt;/p&gt;

&lt;h2 id=&quot;garbage-collector-b-thu-gom-rc&quot;&gt;Garbage Collector (Bộ thu gom rác)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Garbage Collector là 1 trong những bộ phận xác định và loại bỏ 1 số object không được sử dụng khỏi bộ nhớ Heap.&lt;/li&gt;
  &lt;li&gt;Không gian trống này sẽ được cấp phát cho những object mới.&lt;/li&gt;
  &lt;li&gt;Với ngôn ngữ C thì việc khởi tạo và giải phóng bộ nhớ được thực hiện 1 cách thủ công. Nhưng với Ruby và 1 số ngôn ngữ khác thì được thực hiện 1 cách tự động.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ruby-s-dng-memory-nh-th-no&quot;&gt;Ruby sử dụng memory như thế nào?&lt;/h2&gt;

&lt;h4 id=&quot;objects&quot;&gt;Objects&lt;/h4&gt;

&lt;p&gt;Trong Ruby, bất cứ thứ gì đều là object và được biểu diễn như cấu trúc &lt;code&gt;RVALUE&lt;/code&gt;. &lt;code&gt;sizeof(RVALUE)&lt;/code&gt; được tính như sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;20 bytes in 32-bit architecture when double is 4-byte aligned&lt;/li&gt;
  &lt;li&gt;24 bytes in 32-bit architecture when double is 8-byte aligned&lt;/li&gt;
  &lt;li&gt;40 bytes in 64-bit architecture&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Chúng ta có thể xem được thông tin về object thông qua 1 số tools debugger. Ví dụ như &lt;code&gt;gdb&lt;/code&gt; với Linux, và &lt;code&gt;lldb&lt;/code&gt; với Mac OS.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gdb `rbenv which ruby`
(gdb) p sizeof(RVALUE)
$1 = 40
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ruby-objects-heap&quot;&gt;Ruby Objects Heap&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Ruby cấp phát vùng nhớ cho object trong heap space - cái này bao gồm nhiều heap pages.&lt;/li&gt;
  &lt;li&gt;Mỗi heap page bao gồm nhiều slots, mỗi slot dành cho 1 object.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Khi Ruby muốn cấp phát vùng nhớ cho object, nó sẽ tìm xem slot nào chưa được sử dụng từ heap. Nếu không có free slot nào thì khi đó Ruby sẽ tạo thêm heap page. Số lượng heap page được thêm vào phụ thuộc vào tình trạng của heap page hiện tại, version ruby, heap growth algorithm.&lt;/p&gt;

&lt;h4 id=&quot;ruby-18&quot;&gt;Ruby 1.8&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Ruby 1.8 sẽ add 1 heap page 1 lần&lt;/li&gt;
  &lt;li&gt;First page sẽ được tạo khi mà khởi động ứng dụng, bao gồm &lt;code&gt;HEAP_MIN_SLOTS&lt;/code&gt; slots. Mặc định giá trị này là 10.000&lt;/li&gt;
  &lt;li&gt;Số slot của trang sau sẽ bằng slot trang trước * 1.8&lt;/li&gt;
  &lt;li&gt;Ví dụ: Trang đầu có 10.000 slots, trang 2 sẽ có 18.000 slots, trang 3 sẽ có 32.400 slots…&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ruby-19-and-20&quot;&gt;Ruby 1.9 and 2.0&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Từ Ruby 1.9 trở về sau sẽ có thuật toán heap growth khác với 1.8&lt;/li&gt;
  &lt;li&gt;Thay cho việc add mỗi page 1 lần thì nó sẽ thực hiện việc pre-allocate 1 vài page.&lt;/li&gt;
  &lt;li&gt;Khi startup, Ruby 1.9 sẽ pre-allocate &lt;code&gt;HEAP_MIN_SLOTS / HEAP_OBJ_LIMIT&lt;/code&gt; heap pages. Mặc định là &lt;code&gt;10.000 / 408 = 24 heap pages&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Khi interpreter mà cần nhiều page hơn thì nó sẽ lấy số lượng page hiện tại đã dùng, nhân với 1.8. Ví dụ: Với 24 pages được tạo lúc startup, Ruby sẽ tăng số lượng page lên &lt;code&gt;24 * 1.8 = 43&lt;/code&gt;, sẽ add &lt;code&gt;43 - 24 = 19&lt;/code&gt; new heap. 43 heaps này sẽ có &lt;code&gt;43 * HEAP_OBJ_LIMIT = 43 * 408 = 17,544&lt;/code&gt; object slots.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ruby-21&quot;&gt;Ruby 2.1&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Thay thế hằng số &lt;code&gt;HEAP_MIN_SLOTS&lt;/code&gt; thành &lt;code&gt;GC_HEAP_INIT_SLOTS&lt;/code&gt;. Mặc định vẫn là 1.8&lt;/li&gt;
  &lt;li&gt;Ruby 2.1 sẽ tạo ra 1 page lúc startup trước khi allocating initial 24 pages.&lt;/li&gt;
  &lt;li&gt;Ruby từ 2.1 trở đi thì sẽ phân chia heap space thành &lt;code&gt;eden&lt;/code&gt; và &lt;code&gt;tomb&lt;/code&gt;. Khi mà allocate object, Ruby sẽ tìm trong &lt;code&gt;eden&lt;/code&gt; những space đang trống đầu tiên. Nếu mà không có thì sẽ lấy free page từ &lt;code&gt;tomb&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;object-memory&quot;&gt;Object Memory&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1 object trong Ruby có thể lưu được 1 lượng hạn chế về dữ liệu, lên đến 40 byte với hệ điều hành Linux 64 bit.&lt;/li&gt;
  &lt;li&gt;Tất cả dữ liệu không lưu vừa trong 1 object thì sẽ tự động được cấp phát động ra bên ngoài heap của Ruby. Khi object được quyét bởi GC thì memory sẽ được giải phóng.&lt;/li&gt;
  &lt;li&gt;Ví dụ: string trong Ruby chỉ lưu đc 23 byte trong &lt;code&gt;RSTRING&lt;/code&gt; object với hệ điều hành 64 bit. Khi chiều dài của string lớn hơn 23 byte thì ruby sẽ cấp phát thêm bộ nhớ cho nó. Cụ thể như ví dụ bên dưới:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;irb(main):003:0&amp;gt; require 'objspace'
=&amp;gt; false
irb(main):004:0&amp;gt; str = 'x'
=&amp;gt; &quot;x&quot;
irb(main):005:0&amp;gt; ObjectSpace.memsize_of(str)
=&amp;gt; 40
irb(main):006:0&amp;gt; str = 'x'*23
=&amp;gt; &quot;xxxxxxxxxxxxxxxxxxxxxxx&quot;
irb(main):007:0&amp;gt; ObjectSpace.memsize_of(str)
=&amp;gt; 40
irb(main):008:0&amp;gt; str = 'x'*24
=&amp;gt; &quot;xxxxxxxxxxxxxxxxxxxxxxxx&quot;
irb(main):009:0&amp;gt; ObjectSpace.memsize_of(str)
=&amp;gt; 65
irb(main):010:0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Với ví dụ bên trên thì với xâu mà có chiều dài hơn 23 bytes thì nó sẽ lưu ra bên ngoài object. Tổng số size là 65 bytes: 40 bytes cho Ruby object ở trong heap, 24 bytes cấp phát động ra bên ngoài heap, và 1 byte cho vấn đề upkeep (bảo trì)&lt;/p&gt;

&lt;h3 id=&quot;know-what-triggers-gc&quot;&gt;Know What Triggers GC&lt;/h3&gt;

&lt;p&gt;GC sẽ điều khiển 2 việc đó là cấp phát object trong heap space và cấp phát memory cho object bên ngoài Ruby heap. 
trigger GC sẽ hoạt động khi:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Không đủ free slot trong heap space.&lt;/li&gt;
  &lt;li&gt;Cấp phát bộ nhớ hiện tại (current memory allocation) đã quá hạn cho phép.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Do vậy mà cứ khi nào tạo object hoặc cấp phát bộ nhớ đều sẽ gọi GC.&lt;/p&gt;

&lt;h4 id=&quot;gc-triggered-by-heap-usage&quot;&gt;GC Triggered by Heap Usage&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Khi mà hết slot trong heap space, GC sẽ được start để giải phóng 1 ít memory. Nếu mà GC không thể giải phóng đủ slots, Ruby sẽ tăng heap space.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gc-triggered-by-malloc-limit&quot;&gt;GC Triggered by Malloc Limit&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Nếu mà cấp phát bộ nhớ nhiều hơn giá trị cho phép thì GC sẽ được start.&lt;/li&gt;
  &lt;li&gt;Ruby 2.0 trở về trước thì định nghĩa giới hạn này bằng hằng số &lt;code&gt;GC_MALLOC_LIMIT&lt;/code&gt;. Giá trị này mặc định là 8 triệu bytes ~ 7.63 MB&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ti-liu-tham-kho&quot;&gt;Tài liệu tham khảo:&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.amazon.com/dp/1680500694&quot;&gt;Ruby Performance Optimization: Why Ruby is Slow, and How to Fix It&lt;/a&gt;
&lt;img src=&quot;https://images-na.ssl-images-amazon.com/images/I/51nNW87Uv3L._SX415_BO1,204,203,200_.jpg&quot; alt=&quot;80x50&quot; /&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 30 Jan 2017 22:30:00 +0900</pubDate>
				<link>/web/linux/2017/01/30/garbage-collector-trong-ruby.html</link>
				<guid isPermaLink="true">/web/linux/2017/01/30/garbage-collector-trong-ruby.html</guid>
			</item>
		
			<item>
				<title>10 kĩ thuật nên biết khi phát triển web</title>
				<description>&lt;p&gt;Trong những năm gần đây thì nhiều kĩ thuật mới được ra đời, kéo theo việc xây dựng trang web cũng trở nên dễ dàng hơn.&lt;/p&gt;

&lt;h2 id=&quot;web-components&quot;&gt;1. Web Components&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://static.techacademy.jp/magazine/wp-content/uploads/2017/01/01-webcomponents-homepage.jpg&quot; alt=&quot;800x400&quot; class=&quot;lead&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nếu chúng ta đã nghe khá nhiều qua cái tên Boostrap thì có lẽ cũng không lạ lẫm gì với cái tên Web Components nữa.
Web Components là 1 cấu trúc mới được thiết kế theo chuẩn HTML5. Nếu sử dụng nó thì ta có thể tạo ra dropdown menu, slide ảnh … 1 cách dễ dàng.&lt;/p&gt;

&lt;p&gt;Ví dụ như chúng ta muốn tạo ra 1 cái menu dưới dạng dropbox. Thay vì cách truyền thống là sử dụng thẻ tag ul thì bây giờ chúng ta chỉ cần sử dụng thẻ tag
là có thể tạo được ngay. Rất đơn giản phải không ak?&lt;/p&gt;

&lt;p&gt;Trang web: &lt;a href=&quot;https://www.webcomponents.org/&quot;&gt;https://www.webcomponents.org/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;polymer&quot;&gt;2. Polymer&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://static.techacademy.jp/magazine/wp-content/uploads/2017/01/02-polymer-project-homepage.jpg&quot; alt=&quot;800x400&quot; class=&quot;lead&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nếu chúng ta dùng quen Web Components thì tiếp theo thư viện Polymer khá là cần thiết. Polymer thì sẽ giúp công việc develop trở nên đơn giản hơn.
Polymer thường hay kết hợp với Web Components để phát triển trang web của bạn tốt hơn.&lt;/p&gt;

&lt;p&gt;Trang web: &lt;a href=&quot;https://www.polymer-project.org/1.0/&quot;&gt;https://www.polymer-project.org/1.0/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;DEMO: &lt;a href=&quot;https://shop.polymer-project.org/&quot;&gt;https://shop.polymer-project.org/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;amp&quot;&gt;3. AMP&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://static.techacademy.jp/magazine/wp-content/uploads/2017/01/03-washington-post-amp-pages.jpg&quot; alt=&quot;800x400&quot; class=&quot;lead&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AMP (Accelerated Mobile Pages) của Google đã thành công trong việc đơn giản hoá trang web nhằm cải thiện tốc độ hiển thị trên thiết bị điện thoại.
Chỉ cần thêm 1 đoạn code rất ngắn là có thể làm được điều đó.&lt;/p&gt;

&lt;p&gt;Nếu chúng ta tối ưu trang web bằng AMP thì:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Tốc độ đọc trang web nhanh hơn.&lt;/li&gt;
  &lt;li&gt;Hình ảnh và video sẽ được load trước, do đó sẽ nâng cao được trải nghiệm người dùng trên thiết bị mobile.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vì hiện nay lượng người dùng duyệt trang web bằng điện thoại cũng khá là nhiều, nên việc lựa chọn AMP cho việc cải thiện trang web
cũng là 1 sự lựa chọn không sai lầm.&lt;/p&gt;

&lt;p&gt;Trang web: &lt;a href=&quot;https://www.ampproject.org/&quot;&gt;https://www.ampproject.org/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;gulp&quot;&gt;4. Gulp&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://static.techacademy.jp/magazine/wp-content/uploads/2017/01/04-gulpjs-homepage.jpg&quot; alt=&quot;800x400&quot; class=&quot;lead&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Gulp là 1 tool để tự động hoá 1 số task được coi là tốn công tốn sức 1 cách tự động. 
Ví dụ như tạo file CSS từ file Sass, tự động cập nhật trang web sau khi thay đổi code …&lt;/p&gt;

&lt;p&gt;Để hiểu rõ hơn về Gulp, bạn có thể tham khảo trang web: &lt;a href=&quot;http://gulpjs.com/&quot;&gt;http://gulpjs.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;typescript&quot;&gt;5. TypeScript&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://static.techacademy.jp/magazine/wp-content/uploads/2017/01/05-typescript-homepage.jpg&quot; alt=&quot;800x400&quot; class=&quot;lead&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Framework AngularJS là 1 trong những sản phẩm của Google về phát triển javascript phía Frontend. Gần đây Google đã đưa ngôn ngữ TypeScript vào như là ngôn ngữ script.
Typescript sẽ giúp cho thời gian viết code giảm xuống, nâng cao hiệu suất làm việc.&lt;/p&gt;

&lt;p&gt;Vì Typescript là mở rộng của Javascript, nên những ai đã từng code Javascript thì việc tìm hiểu và học Typescript sẽ không tốn quá nhiều thời gian vì cách viết được coi là khá giống nhau.&lt;/p&gt;

&lt;p&gt;Trang web: &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;https://www.typescriptlang.org/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;threejs&quot;&gt;6. Three.js&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://static.techacademy.jp/magazine/wp-content/uploads/2017/01/06-threejs-homepage.jpg&quot; alt=&quot;800x400&quot; class=&quot;lead&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nếu ai có quan tâm đến 2D, 3D hoặc WebGL thì three.js là 1 sự lựa chọn hoàn hảo.&lt;/p&gt;

&lt;p&gt;Để biết rõ thêm chi tiết thì tham khảo trang web này: &lt;a href=&quot;https://threejs.org/&quot;&gt;https://threejs.org/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;docker&quot;&gt;7. Docker&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://static.techacademy.jp/magazine/wp-content/uploads/2017/01/07-docker-homepage.jpg&quot; alt=&quot;800x400&quot; class=&quot;lead&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Khi dev 1 dự án nào đó có lẽ việc xây dựng 1 môi trường phát triển có lẽ là 1 điều không thể thiếu được. Docker sẽ là 1 sự lựa chọn hoàn hảo.&lt;/p&gt;

&lt;p&gt;Chi tiết tham khảo. &lt;a href=&quot;https://www.docker.com/&quot;&gt;https://www.docker.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ionic-framework&quot;&gt;8. Ionic Framework&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://static.techacademy.jp/magazine/wp-content/uploads/2017/01/08-ionic-framework-development.jpg&quot; alt=&quot;800x400&quot; class=&quot;lead&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ionic Framework theo mình nghĩ nó là 1 framework mà không hướng đến phát triển web. Đối tượng của nó muốn hướng đến là những web engineer phát triển ứng dụng native bằng ngôn ngữ như javascript, CSS, HTML.&lt;/p&gt;

&lt;p&gt;Ionic là 1 framework free có thể sử dụng phát triển ứng dụng mobile như Android, iOS.&lt;/p&gt;

&lt;p&gt;Ionic Framework: &lt;a href=&quot;http://ionicframework.com/&quot;&gt;http://ionicframework.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;zurbs-libraries&quot;&gt;9. Zurb’s Libraries&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://static.techacademy.jp/magazine/wp-content/uploads/2017/01/09-zurb-foundation-motion-ui.jpg&quot; alt=&quot;800x400&quot; class=&quot;lead&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Phiên bản mới nhất của Foundation chia thành 2 loại:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Foundation for Emails đã có 1 số template trong phát triển Html Mail hoặc là tính năng tự động hoá.&lt;/li&gt;
  &lt;li&gt;Foundation for Sites dùng cho Web.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Motion UI của Zurb là thư viện dùng cho việc tạo animation trên web.&lt;/p&gt;

&lt;p&gt;Foundation for Emails: &lt;a href=&quot;http://foundation.zurb.com/emails.html&quot;&gt;http://foundation.zurb.com/emails.html&lt;/a&gt;
Motion UI: &lt;a href=&quot;http://zurb.com/playground/motion-ui&quot;&gt;http://zurb.com/playground/motion-ui&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;google-web-starter-kit&quot;&gt;10. Google Web Starter Kit&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://static.techacademy.jp/magazine/wp-content/uploads/2017/01/10-google-web-starter-kit.jpg&quot; alt=&quot;800x400&quot; class=&quot;lead&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Google Web Starter Kit có những đặc điểm sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Code lint (chương trình check bug của source code)&lt;/li&gt;
  &lt;li&gt;Tính năng reload trình duyệt, HTTP server, CSS module, website có tính responsive&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Google Web Starter Kit:  &lt;a href=&quot;https://developers.google.com/web/tools/starter-kit/&quot;&gt;https://developers.google.com/web/tools/starter-kit/&lt;/a&gt;&lt;/p&gt;

</description>
				<pubDate>Fri, 20 Jan 2017 18:10:00 +0900</pubDate>
				<link>/web/design/2017/01/20/10-web-technology.html</link>
				<guid isPermaLink="true">/web/design/2017/01/20/10-web-technology.html</guid>
			</item>
		
			<item>
				<title>Serverless Meetup Tokyo #2</title>
				<description>&lt;p&gt;Serverless Meetup là gì?&lt;/p&gt;

&lt;p&gt;Serverless Meetup là một trong những Community về IT để trao đổi ý kiến, kinh nghiệm của bản thân về  Serverless Architecture - đang được vận hành trên 40 quốc gia trên thế giới. Ở trong những buổi meetup này, thì có rất nhiều những kĩ sư khá giỏi của các công ty lớn như Amazon, Microsoft … lên trình bày.&lt;/p&gt;

&lt;p&gt;Ngày trước như mình thấy, ở Việt Nam mình rất ít khi có những buổi như kiểu này. Nhưng có lẽ gần đây cũng đang dần dần thay đổi,
các buổi sermina được tổ chức ở Hà Nội, Tp Hồ Chí Minh…
Bên nhật rất thường hay tổ chức những buổi Meetup kiểu như này, cá nhân mình thấy nó khá là bổ ích vì đôi khi có những thứ không thể tìm kiếm được ở trên mạng.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-ap-northeast-1.amazonaws.com/serverlessmeetup/serverless.png&quot; alt=&quot;800x400&quot; class=&quot;lead&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;agenda&quot;&gt;Agenda&lt;/h1&gt;

&lt;h4 id=&quot;of-20-min-talks-5-of-10-min-talk-and-4-of-lts&quot;&gt;4 of &amp;gt;20 min talks, 5 of 10 min talk and 4 of LTs&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Timeline&lt;/th&gt;
      &lt;th&gt;Title&lt;/th&gt;
      &lt;th&gt;Speaker&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;18:00-19:00&lt;/td&gt;
      &lt;td&gt;Registration &amp;amp; Social&lt;/td&gt;
      &lt;td&gt;/&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;19:00-19:10&lt;/td&gt;
      &lt;td&gt;Opening: 2017年Serverless化していく世界の概況&lt;/td&gt;
      &lt;td&gt;吉田真吾 (セクションナイン)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;19:10-19:35&lt;/td&gt;
      &lt;td&gt;Tune Up AWS Lambda&lt;/td&gt;
      &lt;td&gt;西谷圭介 (AWS)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;20:10-20:30&lt;/td&gt;
      &lt;td&gt;サーバーレスAWS構成でセキュアなSPAを目指す - Cognito+API Gateway+Lambda+DynamoDB+KMS&lt;/td&gt;
      &lt;td&gt;加藤雅之 (ハンズラボ)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;21:00-21:10&lt;/td&gt;
      &lt;td&gt;Firebase+Railsのハイブリッドだからこそできた2ヶ月で2つのチャットアプリを開発した話&lt;/td&gt;
      &lt;td&gt;安尾友佑 (Redish)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;21:25-21:30&lt;/td&gt;
      &lt;td&gt;SEO対策したサイトをAPI Gateway+Lambdaで作ってみた話&lt;/td&gt;
      &lt;td&gt;平田貴大 (カラダメディカ)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Vì tài liệu toàn bằng tiếng nhật nên mọi người thông cảm nhé. có thời gian mình sẽ dịch nó sang tiếng Việt.&lt;/p&gt;

&lt;h1 id=&quot;slide&quot;&gt;Slide&lt;/h1&gt;

&lt;h4 id=&quot;opening-2017serverless&quot;&gt;1. Opening: 2017年Serverless化していく世界の概況&lt;/h4&gt;

&lt;div class=&quot;embed rich SlideShare&quot;&gt;&lt;iframe src=&quot;https://www.slideshare.net/slideshow/embed_code/key/cAUdomU5jrU1wE&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/YoshidaShingo/welcometoserverlessmeetuptokyo2&quot; title=&quot;Serverless Meetup Tokyo #2 オープニング&quot; target=&quot;_blank&quot;&gt;Serverless Meetup Tokyo #2 オープニング&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.slideshare.net/YoshidaShingo&quot;&gt;Shingo Yoshida&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

&lt;/div&gt;

&lt;h4 id=&quot;tune-up-aws-lambda&quot;&gt;2. Tune Up AWS Lambda&lt;/h4&gt;

&lt;div class=&quot;embed rich SlideShare&quot;&gt;&lt;iframe src=&quot;https://www.slideshare.net/slideshow/embed_code/key/BYEXaD5TtCWVmt&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/keisuke69/tune-up-aws-lambda&quot; title=&quot;Tune Up AWS Lambda&quot; target=&quot;_blank&quot;&gt;Tune Up AWS Lambda&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.slideshare.net/keisuke69&quot;&gt;Keisuke Nishitani&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

&lt;/div&gt;

&lt;h4 id=&quot;awsspa---cognitoapi-gatewaylambdadynamodbkms&quot;&gt;3. サーバーレスAWS構成でセキュアなSPAを目指す - Cognito+API Gateway+Lambda+DynamoDB+KMS&lt;/h4&gt;

&lt;div class=&quot;embed rich SlideShare&quot;&gt;&lt;iframe src=&quot;https://www.slideshare.net/slideshow/embed_code/key/EGcK7bEM80x35I&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/masayuki-kato/serverless-awsspa&quot; title=&quot;Serverless AWS構成でセキュアなSPAを目指す&quot; target=&quot;_blank&quot;&gt;Serverless AWS構成でセキュアなSPAを目指す&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.slideshare.net/masayuki-kato&quot;&gt;Masayuki Kato&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

&lt;/div&gt;

&lt;h4 id=&quot;firebaserails22&quot;&gt;4. Firebase+Railsのハイブリッドだからこそできた2ヶ月で2つのチャットアプリを開発した話&lt;/h4&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://docs.google.com/presentation/d/16C2Y-W2nzbTpDS0_Y6DWxADYG7z84eFgR069-2P57Bw/edit#slide=id.g1be93bed3f_0_127&quot;&gt;https://docs.google.com/presentation/d/16C2Y-W2nzbTpDS0_Y6DWxADYG7z84eFgR069-2P57Bw/edit#slide=id.g1be93bed3f_0_127&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;seoapi-gatewaylambda&quot;&gt;5. SEO対策したサイトをAPI Gateway+Lambdaで作ってみた話&lt;/h4&gt;

&lt;div class=&quot;embed rich SlideShare&quot;&gt;&lt;iframe src=&quot;https://www.slideshare.net/slideshow/embed_code/key/l8pUhx0Q3eE58o&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/ssuserb2e85a/seoapi-gatewaylambda&quot; title=&quot;SEO対策したサイトをAPI Gateway+Lambdaで作った話&quot; target=&quot;_blank&quot;&gt;SEO対策したサイトをAPI Gateway+Lambdaで作った話&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.slideshare.net/ssuserb2e85a&quot;&gt;Takahiro Hirata&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

&lt;/div&gt;
</description>
				<pubDate>Thu, 19 Jan 2017 22:10:00 +0900</pubDate>
				<link>/serverless/meetup/2017/01/19/serverless-meetup-tokyo-2.html</link>
				<guid isPermaLink="true">/serverless/meetup/2017/01/19/serverless-meetup-tokyo-2.html</guid>
			</item>
		
	</channel>
</rss>
